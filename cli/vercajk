#!/usr/bin/env python3

"""
This should be rather bash cli, but I really hate building bash cli
"""


import subprocess
from pathlib import Path
from typing import Iterable

import click


class VercajkException(Exception):
    pass


def _get_vercajk_path() -> Path:
    vercajk_path_file = Path("~/.local/share/vercajk/vercajk_path").expanduser()
    if not vercajk_path_file.exists():
        raise VercajkException(
            "You have to first define the vercajk repo path to use this tool"
        )

    with open(vercajk_path_file, "r") as vercajk_path_f:
        return Path(vercajk_path_f.readline().strip())


def _get_user_specified_tools(what: tuple[str], tools: Iterable[Path]) -> list[Path]:
    result = []
    for tool in tools:
        if tool.name in what:
            result.append(tool)

    return result


@click.group()
def entry_point() -> None:
    pass


@entry_point.command("update")
@click.option(
    "-e",
    "--exclude",
    type=str,
    required=False,
    multiple=True,
    help="Exclude these tools from update."
)
@click.argument(
    "what",
    type=str,
    required=False,
    nargs=-1,
)
def update(exclude: tuple[str], what: tuple[str]) -> None:
    """
    Update vercajk from this repo to your Linux machine.

    Args:
        what: Specify what to update. Can be multiple.
    """
    available_tools = (Path(_get_vercajk_path()) / "vercajk").iterdir()
    if what:
        tools = _get_user_specified_tools(what, available_tools)
    else:
        tools = available_tools

    excluded_tools = []
    for tool in tools:
        if tool.name not in exclude:
            excluded_tools.append(tool)

    for tool in excluded_tools:
        process = subprocess.run(["bash", tool / "_install.sh"], cwd=tool)
        if process.returncode != 0:
            exit(process.returncode)


@entry_point.command("test")
def test() -> None:
    """
    Test whether new changes will install in fresh Linux (fedora for now) installation

    Returns:
        Exits with failure if tests won't pass
    """
    process = subprocess.run(["bash", "./test_deploy.sh"], cwd=_get_vercajk_path() / "test")
    exit(process.returncode)


@entry_point.command("dir")
def vercajk_working_directory() -> None:
    """
    Print vercajk's directory
    """
    print(str(_get_vercajk_path()))


if __name__ == "__main__":
    entry_point()
